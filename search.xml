<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[hexo设置特定文件不使用模板渲染]]></title>
    <url>%2Fmixture%2F224b403e.html</url>
    <content type="text"><![CDATA[不使用模板渲染文章把md文章文件头部layout设置为false 123456---title: 此文章不使用模板渲染categories: hexodate: 2019-09-18 12:25:57layout: false--- 这个方法一般不会使用，很不美观。 不使用模板渲染目录或文件Hexo默认会对/source/里的所有页面应用主题模板渲染。有时候，我需要展示我写的html页面，需要一个干净的页面，关闭模板渲染。我的html、css、js、image放在/source/assets/。打开根目录下的_config.yml，搜索skip_render: 1skip_render: assets/** assets/**表示不使用模板渲染此目录下所有的文件，跳过单独文件可以写assets/index.html 如何访问？我的文件目录： 123456- source - assets index.html style.css main.js photo.jpg 在浏览器打开：http://localhost:4000/assets/index.html 在文章内引用：123&lt;http://localhost:4000/assets/index.html&gt;[这是我的demo首页](/assets/index.html)![这是我的图片](/assets/photo.jpg)]]></content>
      <categories>
        <category>混合</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rem自适应布局]]></title>
    <url>%2Ffront-end%2F5a82277e.html</url>
    <content type="text"><![CDATA[remrem是CSS3新增的相对长度单位，是指相对于根元素html的font-size计算值的大小。简单可理解为屏幕宽度的百分比。 写代码时，按照设计稿的尺寸对应转换单位成rem。一般我使用宽750px的设计稿，除以100是为了方便计算。设计稿上元素宽度50px，在css里面就是50/100=0.5rem。设计稿里面元素宽度750px，在css里面就写7.5rem，在任何尺寸上这个7.5rem刚刚好是屏幕的宽度，网页按照设计稿比例布局！ DOMContentLoaded，文档加载完成计算根字体大小。 resize，监听网页可视宽度变化，动态设置html的根字体大小，因为网页按照设计稿比例来布局，屏幕窗口改变，根字体大小重新计算。 实现rem自适应布局核心代码就这几句： 1234567891011121314! function (n) &#123; var doc = n.document, el = doc.documentElement, designW = 750, p = designW / 100, event = &quot;orientationchange&quot; in n ? &quot;orientationchange&quot; : &quot;resize&quot;, fun = function () &#123; var clientW = el.clientWidth&lt;320?320:el.clientWidth; el.style.fontSize = clientW / p + &quot;px&quot; console.log(clientW / p) &#125;; doc.addEventListener &amp;&amp; (n.addEventListener(event, fun, false), doc.addEventListener(&quot;DOMContentLoaded&quot;, fun, false))&#125;(window); 在线demo，按f12，尝试在不同屏幕大小的设备中展示。demo的css：style.css，iconfont.css 设计图： 其他 在不同的尺寸上布局是等比例了，但是元素字体大小我使用的是em，大屏幕上字体显得很小，如果用rem作为字体大小单位，可以等比例变大缩小。 demo中menu的iconfont图标就是使用rem作为字体大小单位。 在屏幕小于320px的时候，元素放不下会挤开，所以我在demo中设置了根字体最小也要按照320px的宽度转换。 document：.html文档;documentElement：整个节点树的根节点root，即&lt;html&gt; 标签;body：DOM对象里的body子节点，即 &lt;body&gt; 标签; &lt;!DOCTYPE html&gt;相关说明https://blog.csdn.net/zxf13598202302/article/details/51162637：页面具有 DTD，或者说指定了 DOCTYPE 时，使用 document.documentElement。页面不具有 DTD，或者说没有指定了 DOCTYPE 时，使用 document.body。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>rem</tag>
        <tag>自适应</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows10系统启用telnet服务]]></title>
    <url>%2Fmixture%2Fa80cf7e4.html</url>
    <content type="text"><![CDATA[在学习node.js创建TCP服务器，需要与被创建的TCP服务器连接，在另一个命令窗口执行以下代码： 1telnet localhost 8431 然后报： 1telnet: command not found 原因是windows 10 系统没有启用telnet客户端，需要手动开启 启用telnet客户端右击win键-&gt;应用与功能-&gt;程序与功能-&gt;启用或关闭widows功能-&gt;勾选telnet客户端]]></content>
      <categories>
        <category>混合</category>
      </categories>
      <tags>
        <tag>node.js</tag>
        <tag>telnet</tag>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node.js学习笔记（二）]]></title>
    <url>%2Fback-end%2F94441cf.html</url>
    <content type="text"><![CDATA[文件流使用ReadStream对象读取文件 fs.createReadStream(path,[option]) 123456789101112131415161718var fs = require('fs');var file = fs.createReadStream('./msg.txt',&#123;start:3,end:12&#125;);file.on('data',function(data)&#123; console.log(data);&#125;)file.on('end',function()&#123; console.log("文件已经全部读取完毕")&#125;)file.on('close',function()&#123; console.log("文件被关闭");&#125;)file.on('error',function(err)&#123; console.log('读取文件失败');&#125;) 暂停并恢复文件的读取123456789101112131415var fs = require('fs');var file = fs.createReadStream('./msg.txt');console.log("暂停读取...")// 暂停读取file.pause();file.on('data',function(data)&#123; console.log('获取到数据：'+data);&#125;)setTimeout(function()&#123; // 恢复读取 file.resume(); console.log("恢复读取...")&#125;,4000); 使用 createWriteStream 方法写入文件1234567891011121314151617181920var fs = require('fs');var file = fs.createReadStream('./msg.txt');var out = fs.createWriteStream('anothermsg.txt');file.on('data',function(data)&#123; // writable.write([chunk],[encoding],[callback]); out.write(data);&#125;);out.on('open',function()&#123; console.log('需要被写入的文件已被打开');&#125;)file.on('end',function()&#123; // writable.end([chunk],[encoding],[callback]) // '再见'会追加到anothermsg.txt末尾 out.end('再见',function()&#123; console.log('文件全部写入完毕，字节：',out.bytesWritten); &#125;)&#125;) 使用 WriteStream 对象的write 方法中的callback参数指定回调函数12345678910var fs = require('fs');var file = fs.createReadStream('./msg.txt');var out = fs.createWriteStream('anothermsg.txt');file.on('data',function(data)&#123; // writable.write([chunk],[encoding],[callback]); out.write(data,function()&#123; console.log(data.toString()) &#125;);&#125;); 观察 WriteStream 对象的write 方法的返回结果并监听drain事件当操作系统缓存区中的数据全部写满时，不代表不能继续写数据。而是指在将操作系统缓存区中的数据写入到文件中的同时把读取到的数据暂时缓存在内存中，待操作系统缓存区数据已全部输出时首先将内存中缓存的数据读入操作系统缓存区中。当操作系统缓存区中的数据已被全部读出并写入到目标文件时，触发WriteStream对象的drain事件，表示操作统缓存区中的数据已被全部读出，可以继续向操作系统缓存区中写入新的数据。 drain事件触发操作系统缓存区数据写满，返回 false,操作系统缓存区还可以写入数据，返回 true 123456789101112131415161718192021var fs = require('fs');var out = fs.createWriteStream('test1.txt');for (var i = 1; i &lt;= 10000; i++) &#123; var flag = out.write(i.toString()); console.log(flag); // 操作系统缓存区数据写满 false, 操作系统缓存区还可以写入数据 true&#125;out.on('drain', function () &#123; console.log('操作系统缓存区中的数据已被全部输出,1'); var out = fs.createWriteStream('test2.txt'); for (var i = 1; i &lt;= 10; i++) &#123; var flag = out.write(i.toString()); console.log(flag); &#125; out.on('drain',function()&#123; // 这里的drain事件不会被触发，因为1-10个数据不会填满操作系统缓存区 console.log('操作系统缓存区中的数据已被全部输出,2'); &#125;)&#125;) error事件回调函数的使用12345678910var fs = require('fs');var out = fs.createWriteStream('msg.txt');out.on('error',function(err)&#123; console.log('写文件操作发生错误');&#125;)out.write('一些测试数据');out.end();out.write('一些新数据'); // 该行代码将引起一个操作错误 使用pipe方法复制文件 readStream.pipe(destination,[option]); 12345var fs = require('fs');var file = fs.createReadStream('./msg.mp3');var out = fs.createWriteStream('./anothermsg.mp3');// msg.mp3复制到anothermsg.mp3file.pipe(out); 将end属性值设置为false以在目标文件中追加数据123456789var fs = require('fs');var file = fs.createReadStream('./msg.txt');var out = fs.createWriteStream('./anothermsg.txt');// msg.txt复制到anothermsg.txtfile.pipe(out,&#123;end:false&#125;);file.on('end',function()&#123; // '再见。'追加到anothermsg.txt末尾 out.end('再见。');&#125;) 使用unpipe方法取消目标文件写入操作123456789var fs = require('fs');var file = fs.createReadStream('./test1.txt');var out = fs.createWriteStream('./anothertest.txt');file.pipe(out,&#123;end:false&#125;);setTimeout(function()&#123; file.unpipe(out); out.end();&#125;,10)]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>node.js</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node.js学习笔记]]></title>
    <url>%2Fback-end%2F3c2bd137.html</url>
    <content type="text"><![CDATA[判断是否主模块在模块中写入： 12var a = module === require.main;console.log(a) // true 主模块，false 非主模块 例如：node app.js那么，app.js就是主模块 引用同一个模块不会引起模块内的代码多次运行引入模块，加载模块时会执行模块里面的全部代码，模块加载后将缓存到内存缓存区中，主模块多次引用同一个模块不会引起模块内的代码多次运行。 123var test1 = require('./testModule.js');var test2 = require('./testModule.js');var test3 = require('./testModule.js'); 获取模块文件名和当前目录12console.log("获取模块文件名:",__filename)console.log("获取当前目录:",__dirname) 取消事件的所有事件处理函数1234567891011121314151617181920212223242526272829var http = require('http');var server = http.createServer();server.on('request', function (req, res) &#123; if (req.url !== '/favicon.ico') &#123; console.log("收到客户端请求"); &#125;&#125;);server.on('request', function (req, res) &#123; // 不处理收藏加图标的请求 if (req.url !== '/favicon.ico') &#123; console.log(req.url); &#125; res.end();&#125;);// 取消'request'事件的所有事件处理函数server.removeAllListeners('request');server.on('request', function (req, res) &#123; if (req.url !== '/favicon.ico') &#123; console.log('你可以在控制台看到这句'); &#125; res.end();&#125;);server.listen(1234, "127.0.0.1"); removeAllListeners方法中使用事件名称参数时，将取消该事件的所有事件处理函数removeAllListeners方法中不使用事件名称参数时，将取消所有已被指定的事件 查看npm包全局安装路径1npm root -g 修改全局安装路径修改到 d:\node\node_module 1npmconfig set prefix &quot;d:\node&quot; 文件读写参数‘r’：读取文件．如果文件不存在则抛出异常。‘r+’：读取并写入文件，如果文件不存在则抛出异常。‘rs’：以同步方式读取文件并通知操作系统忽略本地文件系统缓存．如果文件不存在则抛出异常。由于该属性值的使用将使操作系统忽略本地文件系统缓存机制，因此在操作网络文件系统时建议使用该属性值，但由于其对性能产生一定的负面影响．所以在其他场合下不建议使用。‘w’：写人文件。如果文件不存在则创建该文件，如果该文件已存在则清空文件内容。‘wx’：作用与W类似，但是如果文件路径存在，则文件写入失败。‘w+’：读取并写人文件。如果文件不存在则创建该文件，如果该文件巳存在则清空文件内容。‘wx+’： 作用与’w+’类似，则文件读写失败。‘a’：追加写人文件。如果文件不存在则创建该文件。‘ax’：作用与’a’类似，但是如果文件路径存在，则文件追加失败。‘a+’：读取并追加写人文件，如果文件存在则创建该文件 。‘ax+’：类似 ‘a+’， 但是如果文件路径存在，则文件读取追加失败。 Buffer(缓冲区) 看书看不懂Buffer怎么使用，去官网或者菜鸟教程看一遍。node.js中文文档-buffer：http://nodejs.cn/api/buffer.html菜鸟教程-Node.js Buffer(缓冲区)：https://www.runoob.com/nodejs/nodejs-buffer.html Buffer类用来创建一个专门存放二进制数据的缓存区。 在 Node.js 中，Buffer 类是随 Node 内核一起发布的核心库。Buffer 库为 Node.js 带来了一种存储原始数据的方法，可以让 Node.js 处理二进制数据，每当需要在 Node.js 中处理I/O操作中移动的数据时，就有可能使用 Buffer 库。原始数据存储在 Buffer 类的实例中。一个 Buffer 类似于一个整数数组，但它对应于 V8 堆内存之外的一块原始内存。 在v6.0之前创建Buffer对象直接使用new Buffer()构造函数来创建对象实例，但是Buffer对内存的权限操作相比很大，可以直接捕获一些敏感信息，所以在v6.0以后，官方文档里面建议使用 Buffer.from() 接口去创建Buffer对象。 Buffer 与字符编码Buffer 实例一般用于表示编码字符的序列，比如 UTF-8 、 UCS2 、 Base64 、或十六进制编码的数据。 通过使用显式的字符编码，就可以在 Buffer 实例与普通的 JavaScript 字符串之间进行相互转换。 1234567const buf = Buffer.from('runoob', 'ascii');// 输出 72756e6f6f62console.log(buf.toString('hex'));// 输出 cnVub29iconsole.log(buf.toString('base64')); Node.js 目前支持的字符编码包括： ascii - 仅支持 7 位 ASCII 数据。如果设置去掉高位的话，这种编码是非常快的。 utf8 - 多字节编码的 Unicode 字符。许多网页和其他文档格式都使用 UTF-8 。 utf16le - 2 或 4 个字节，小字节序编码的 Unicode 字符。支持代理对（U+10000 至 U+10FFFF）。 ucs2 - utf16le 的别名。 base64 - Base64 编码。 latin1 - 一种把 Buffer 编码成一字节编码的字符串的方式。 binary - latin1 的别名。 hex - 将每个字节编码为两个十六进制字符。 创建 Buffer 类Buffer 提供了以下 API 来创建 Buffer 类： Buffer.alloc(size[, fill[, encoding]])： 返回一个指定大小的 Buffer 实例，如果没有设置 fill，则默认填满 0 Buffer.allocUnsafe(size)： 返回一个指定大小的 Buffer 实例，但是它不会被初始化，所以它可能包含敏感的数据 Buffer.allocUnsafeSlow(size) Buffer.from(array)： 返回一个被 array 的值初始化的新的 Buffer 实例（传入的 array 的元素只能是数字，不然就会自动被 0 覆盖） Buffer.from(arrayBuffer[, byteOffset[, length]])： 返回一个新建的与给定的 ArrayBuffer 共享同一内存的 Buffer。 Buffer.from(buffer)： 复制传入的 Buffer 实例的数据，并返回一个新的 Buffer 实例 Buffer.from(string[, encoding])： 返回一个被 string 的值初始化的新的 Buffer 实例 1234567891011121314151617181920// 创建一个长度为 10、且用 0 填充的 Buffer。const buf1 = Buffer.alloc(10);// 创建一个长度为 10、且用 0x1 填充的 Buffer。 const buf2 = Buffer.alloc(10, 1);// 创建一个长度为 10、且未初始化的 Buffer。// 这个方法比调用 Buffer.alloc() 更快，// 但返回的 Buffer 实例可能包含旧数据，// 因此需要使用 fill() 或 write() 重写。const buf3 = Buffer.allocUnsafe(10);// 创建一个包含 [0x1, 0x2, 0x3] 的 Buffer。const buf4 = Buffer.from([1, 2, 3]);// 创建一个包含 UTF-8 字节 [0x74, 0xc3, 0xa9, 0x73, 0x74] 的 Buffer。const buf5 = Buffer.from('tést');// 创建一个包含 Latin-1 字节 [0x74, 0xe9, 0x73, 0x74] 的 Buffer。const buf6 = Buffer.from('tést', 'latin1'); 写入缓冲区语法写入 Node 缓冲区的语法如下所示： 1buf.write(string[, offset[, length]][, encoding]) 参数参数描述如下： string - 写入缓冲区的字符串。 offset - 缓冲区开始写入的索引值，默认为 0 。 length - 写入的字节数，默认为 buffer.length encoding - 使用的编码。默认为 ‘utf8’ 。 根据 encoding 的字符编码写入 string 到 buf 中的 offset 位置。 length 参数是写入的字节数。 如果 buf 没有足够的空间保存整个字符串，则只会写入 string 的一部分。 只部分解码的字符不会被写入。 返回值返回实际写入的大小。如果 buffer 空间不足， 则只会写入部分字符串。 实例 123buf = Buffer.alloc(256);len = buf.write("www.runoob.com");console.log("写入字节数 : "+ len); // 写入字节数 : 14 从缓冲区读取数据语法读取 Node 缓冲区数据的语法如下所示： 1buf.toString([encoding[, start[, end]]]) 参数参数描述如下： encoding - 使用的编码。默认为 ‘utf8’ 。 start - 指定开始读取的索引位置，默认为 0。 end - 结束位置，默认为缓冲区的末尾。 返回值解码缓冲区数据并使用指定的编码返回字符串。 实例 123456789buf = Buffer.alloc(26);for (var i = 0 ; i &lt; 26 ; i++) &#123; buf[i] = i + 97;&#125;console.log( buf.toString('ascii')); // 输出: abcdefghijklmnopqrstuvwxyzconsole.log( buf.toString('ascii',0,5)); // 输出: abcdeconsole.log( buf.toString('utf8',0,5)); // 输出: abcdeconsole.log( buf.toString(undefined,0,5)); // 使用 'utf8' 编码, 并输出: abcde 将缓冲区内数据用fs.write写入使用fs.open打开的文件 fs.write(fd, buffer[, offset[, length[, position]]], callback)fs.write文档：http://nodejs.cn/api/fs.html#fs_fs_write_fd_string_position_encoding_callback 将 buffer 写入到 fd 指定的文件。 参数 fd &lt;integer&gt; 使用fs.open打开成功后返回的文件描述符 buffer &lt;Buffer&gt; | | &lt;DataView&gt; Buffer对象 offset &lt;integer&gt; 从缓存区中读取时的初始位置，以字节为单位 length &lt;integer&gt; 从缓存区中读取数据的字节数 position &lt;integer&gt; 写入文件初始位置 callback &lt;Function&gt; 回调函数 err &lt;Error&gt; 错误信息 written &lt;integer&gt; 写入的字节数 buffer &lt;string&gt; 被读取的缓存区对象 例子： 12345678910111213141516var fs = require('fs');var buf = Buffer.from('我爱编程');console.log(buf)console.log("准备打开文件")fs.open('./mesage.txt', 'w', function (err, fd) &#123; if (err) console.log("打开文件失败"); console.log("文件描述符：", fd) fs.write(fd, buf, 3, 9, 0, function (err, written, buffer) &#123; if (err) console.log("写文件操作失败"); console.log("文件操作成功"); console.log('写入的字节数：', written) console.log('buffer：', buffer) console.log('被读取的缓存区对象:',buffer.toString()) &#125;)&#125;) 打印结果： 1234567&lt;Buffer e6 88 91 e7 88 b1 e7 bc 96 e7 a8 8b&gt;准备打开文件文件描述符： 3文件操作成功写入的字节数： 9buffer： &lt;Buffer e6 88 91 e7 88 b1 e7 bc 96 e7 a8 8b&gt;被读取的缓存区对象: 我爱编程 mesage.txt： 1爱编程 fs.fsync 方法确保文件全部写入文件读写操作执行完毕后，需要关闭此文件，尤其是在文件排他方式打开的时候。 close使用方法： 1fs.close(fd,[callback]) fd参数值必须为open方法所使用的回调函数中返回的文件描述符。callback为可选参数。 在使用write方法或writeSync方法在文件中写入数据时，操作系统首先将该部分读到内存中，再把数据写到文件中，当数据读取完时并不代表数据已经写完，因为还有一部分有可能会留在内存缓冲区中，这时用close方法或closeSync方法关闭文件，那么这部分数据就会丢失，这时，可以调用fs模块中的fsync方法对文件进行同步操作，即将内存缓冲区中的剩余数据全部写入文件。 fsync使用方法： 1fs.fsync(fd,[callback]) fd参数值必须为open方法所使用的回调函数中返回的文件描述符。callback为可选参数。 代码： 1234567891011var fs = require('fs');var buf = new Buffer('我喜爱编程');fs.open('./msg.txt','wx',function(err,fd)&#123; fs.write(fd,buf,0,15,0,function(err,written,buffer)&#123; if(err) console.log("写入文件失败"); else console.log("写入文件成功"); fs.fsync(fd); fs.close(fd); &#125;)&#125;) 读取文件状态var fs = require(‘fs’); 123fs.stat('./msg.txt',function(err,stats)&#123; console.log(stats)&#125;) Stats { dev: 3873559124, mode: 33206, nlink: 1, uid: 0, gid: 0, rdev: 0, blksize: undefined, ino: 3096224743946298, size: 15, blocks: undefined, atimeMs: 1568170744889, mtimeMs: 1568170744889, ctimeMs: 1568170744890.2546, birthtimeMs: 1568165654890.947, atime: 2019-09-11T02:59:04.889Z, mtime: 2019-09-11T02:59:04.889Z, ctime: 2019-09-11T02:59:04.890Z, birthtime: 2019-09-11T01:34:14.891Z } stats.atime “访问时间” - 上次访问文件数据的时间。 stats.mtime “修改时间” - 上次修改文件数据的时间。 stats.ctime “更改时间” - 上次更改文件状态（修改索引节点数据）的时间。 stats.birthtime “创建时间” - 创建文件的时间。当创建文件时设置一次。 fs.exists 检查文件是否存在123fs.exists('./msg.txt',function(exists)&#123; console.log(exists)&#125;) 获取文件绝对路径12345fs.realpath('./msg.txt',function(err,resolvedPath)&#123; if(err) throw err; // 回调函数代码 console.log(resolvedPath);&#125;); 修改文件访问时间及修改时间 fs.utimes(path,atime,mtime,callback) 12345fs.utimes('./msg.txt',new Date(),new Date(),function(err)&#123; if(err) console.log("修改文件时间失败") // 回调函数代码 console.log("修改文件时间成功");&#125;); 修改文件读写权限 fs.chamod(path,mode,callback) 12345// 0600代表所有者可以读写，其他人没有任何权限fs.chmod('./msg.txt',0600,function(err)&#123; if(err) console.log("修改文件权限失败"); else console.log("修改文件权限成功")&#125;); 0600 所有者可以读写，其他人没有任何权限 0644 所有者可读写，其他人只读 0755 所有者有所有权限，其他人可读可执行 0740 所有者有所有权限，所有者所在的组只读 创建文件硬链接 fs.link(srcpath,dstpath,callback) 12345var fs = require('fs');fs.link('./test.txt','./test/test2.txt',function(err)&#123; if(err) console.log("创建文件硬链接失败"); else console.log("创建文件硬链接成功");&#125;); 删除文件硬链接 fs.unlink(srcpath,dstpath,callback) 12345var fs = require('fs');fs.unlink('./test.txt',function(err)&#123; if(err) console.log("删除文件硬链接失败"); else console.log("删除文件硬链接成功");&#125;); rmdir 删除空目录 fs.rmdir(path,callback) 1234fs.rmdir('./c',function(err)&#123; if(err) console.log("删除空目录失败",err); else console.log("删除空目录成功");&#125;); watchFile 监听文件或目录 fs.watchFile(filename,[options],listener) filename &lt;string&gt; | &lt;Buffer&gt; | &lt;URL&gt; options &lt;Object&gt; persistent &lt;boolean&gt; 默认值: true。 interval &lt;integer&gt; 默认值: 5007。 listener &lt;Function&gt; current &lt;fs.Stats&gt; previous &lt;fs.Stats&gt; 监视 filename 的更改。 每当访问文件时都会调用 listener 回调。options 参数可以省略。 如果提供，则它应该是一个对象。 options 对象可以包含一个名为 persistent 的布尔值，指示当文件正在被监视时，进程是否应该继续运行。 options 对象可以指定 interval 属性，指示轮询目标的频率（以毫秒为单位）。listener 有两个参数，当前的 stat 对象和之前的 stat 对象： 1234fs.watchFile('message.text', (curr, prev) =&gt; &#123; console.log(`当前的最近修改时间是: $&#123;curr.mtime&#125;`); console.log(`之前的最近修改时间是: $&#123;prev.mtime&#125;`);&#125;); 例子： 123456var fs = require('fs');fs.watchFile('./message.txt',&#123;persistent:true&#125;,function(curr,prev)&#123; if(Date.parse(curr.ctime)==0) &#123; console.log('message.txt文件为'+curr.size+'字节'); &#125;&#125;) 1234567891011121314var fs = require('fs');// 每个一小时监听一次fs.watchFile('./message.txt',&#123;interval:60*60*5000&#125;,function(curr,prev)&#123; console.log(curr) console.log(prev) // 略&#125;)// 监听同一个文件fs.watchFile('./message.txt',function(curr,prev)&#123; if(Date.parse(curr.ctime)==0) &#123; console.log('message.txt文件为'+curr.size+'字节'); &#125;&#125;) unwatchFile 取消监听文件或目录 fs.unwatchFile(filename, listener) 12345678910111213var fs = require('fs');var fn1 = function(curr,prev)&#123; console.log("这里时fn1")&#125;var fn2 = function(curr,prev)&#123; console.log("这里时fn2")&#125;fs.watchFile('./message.txt',fn1);fs.watchFile('./message.txt',fn2);fs.unwatchFile('./message.txt',fn1); $ node app.9.js 这里时fn2 watch 监视文件 fs.watch(filename,[options] [listener])var watcher = fs.watch(filename,[options] [listener]) filename &lt;string&gt; | &lt;Buffer&gt; | &lt;URL&gt; options &lt;string&gt; | &lt;Object&gt; persistent &lt;boolean&gt; 指示如果文件已正被监视，进程是否应继续运行。默认值: true。 recursive &lt;boolean&gt; 指示应该监视所有子目录，还是仅监视当前目录。这适用于监视目录时，并且仅适用于受支持的平台（参阅注意事项）。默认值: false。 encoding &lt;string&gt; 指定用于传给监听器的文件名的字符编码。默认值: ‘utf8’。 listener &lt;Function&gt; | &lt;undefined&gt; 默认值: undefined。 eventType &lt;string&gt; filename &lt;string&gt; | &lt;Buffer&gt; 返回: &lt;fs.FSWatcher&gt; fs.watch：http://nodejs.cn/api/fs.html#fs_fs_watch_filename_options_listener 12345var fs = require('fs');fs.watch('./message.txt',function(event,filename)&#123; console.log(event); console.log(filename)&#125;); 123456var fs = require('fs');var watcher = fs.watch('./msg.txt',function(event,filename)&#123; console.log(event); console.log(filename) watcher.close(); // 触发事件后停止监视文件停止程序运行&#125;);]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>node.js</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node.js：console对象]]></title>
    <url>%2Fback-end%2Fb83ce424.html</url>
    <content type="text"><![CDATA[标准输出流conosole.log方法用于进行标准输出流的输出，即在控制台中显示一行字符串。 12// app.jsconsole.log("hello node.js") 运行 1node app.js 标准输出流将输出到控制台 hello node.js 重定向标准输出流将app.js输出的字符串输出到info.log文件中，（1代表重定向标准输出流） 1node app.js 1&gt;info.log 如果没有info.log，它会自动创建并写入。 打开info.log可以看到： 1hello node.js 标准错误输出流重定向输出将app.js错误信息输出的字符串输出到error.log文件中，（2代表重定向标准错误输出流） 1234// app.jsconsole.error("This is a test")// 或者输出一个未定义的变量// conosole.log(name) 如果没有error.log，它会自动创建并写入。 打开error.log可以看到： 123456node : This is a test所在位置 行:1 字符: 1+ node app.js 2&gt;error.log+ ~~~~~~~~~~~~~~~~~~~~~~~ + CategoryInfo : NotSpecified: (This is a test:String) [], RemoteException + FullyQualifiedErrorId : NativeCommandError 统计一段代码执行时间console.time(label)console.timeEnd(label) 这两个方法使用一个参数，并且这个两个方法使用的参数字符串必须相同。 1234567// app.jsconsole.time("test")var q;for(var i=0;i++;i&lt;20)&#123; q+=1;&#125;console.timeEnd("test") 运行： 1node app.js 结果： test: 0.086ms]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文档、书籍、网站分享]]></title>
    <url>%2Fshare%2F74bd31aa.html</url>
    <content type="text"><![CDATA[后端node.js 书籍 《node.js权威指南》 作者: 陆凌牛出版社: 机械工业出版社出版年: 2014-4-1 百度云盘：https://pan.baidu.com/s/1vvYZfVnqn98BdVK39itMnw提取码：d40u node.js 文章、文档 Node.js 中文网文档文档地址：http://nodejs.cn/api/ node.js fs.open 和 fs.write 读取文件和改写文件文章地址： https://www.cnblogs.com/wushanbao/p/7003308.html 七天学会NodeJS文档地址：https://nqdeng.github.io/7-days-nodejs/#1 网站分享 廖雪峰的官方网站网站地址：https://www.liaoxuefeng.com/]]></content>
      <categories>
        <category>分享</category>
      </categories>
      <tags>
        <tag>学习书籍</tag>
        <tag>pdf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[fis3前端工程构建工具]]></title>
    <url>%2Ffront-end%2F664fd9e5.html</url>
    <content type="text"><![CDATA[昨天尝试webapck使用ejs模板配置公用组件，网上关于webpack使用ejs配置公用组件的教程太少了，有几个教程我尝试了，都以失败告终。 ejs官网：https://ejs.bootcss.com/ 开发原生多页面项目，不同于使用vue，repeat这些框架，很多重复的部件，公用头部、底部，导航等等，管理起来太费时间了，好像glup也可以做到公用组件，但是不想要glup。 fis3是一个不错的选择，因为简单容易使用，我只针对使用它的一个功能也足够了。 在html中嵌入资源：http://fis.baidu.com/fis3/docs/user-dev/inline.html html中嵌入页面文件 源码： 1234// index.html&lt;div class="layout"&gt; &lt;link rel="import" href="head.html?__inline"&gt;&lt;/div&gt; 12// head.html (公共组件)&lt;h1&gt;这里是头部&lt;/h1&gt; 编译后： 1234// index.html&lt;div class="layout"&gt; &lt;h1&gt;这里是头部&lt;/h1&gt;&lt;/div&gt; 配置好一个demo，有点贪心加了其他功能进去，github:https://github.com/ywc150148/fis-demo 但是好像挺少人使用fis3，配置sass失败，找不到解决方法。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>fis3</tag>
        <tag>前端工程构建工具</tag>
        <tag>前端公用组件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo及next主题使用遇到的问题]]></title>
    <url>%2Fmixture%2Fb13ba7b7.html</url>
    <content type="text"><![CDATA[我在使用hexo和next主题，期间遇到问题的解决方法一一罗列： 安装使用 next 主题http://theme-next.iissnan.com/ Hexo使用不蒜子统计功能失效问题解决https://www.jianshu.com/p/089762f90e1c hexo博客添加评论神器—valinehttps://blog.csdn.net/qq_40265501/article/details/80019508 Hexo Next 主题中添加本地搜索功能https://blog.csdn.net/lijing742180/article/details/87970909 Hexo之next主题设置首页不显示全文(只显示预览)https://www.jianshu.com/p/393d067dba8d 资源文件夹https://hexo.io/zh-cn/docs/asset-folders.html hexo+github上传图片到博客 (这个会创建很多文件夹，我不使用)https://www.jianshu.com/p/8d28027fec76 建议把图片压缩再放到source文件夹图片在线压缩：https://www.tuhaokuai.com/ hexo禁用特定文章的评论https://blog.csdn.net/jiluben/article/details/40868981]]></content>
      <categories>
        <category>混合</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>hexo next 主题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Funcategorized%2F4a17b156.html</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment 启动 Hexo 本地站点，并开启调试模式1$ hexo s --debug 清除缓存、生产并部署到主分支12$ hexo clean$ hexo d -g]]></content>
  </entry>
  <entry>
    <title><![CDATA[hexo jquery 加载失败问题]]></title>
    <url>%2Fmixture%2F9e5800d1.html</url>
    <content type="text"><![CDATA[昨天部署上线hexo，想在手机上体验一番，但是奈何进度条一直显示加载状态，而且导航栏按钮点击无效。 打开pc谷歌浏览器控制台，提示错误： 123456GET https://ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js net::ERR_CONNECTION_TIMED_OUTjquery.fancybox.pack.js:46 Uncaught ReferenceError: jQuery is not defined at jquery.fancybox.pack.js:46(anonymous) @ jquery.fancybox.pack.js:46script.js:137 Uncaught ReferenceError: jQuery is not defined at script.js:137 打开themes\landscape\layout_partial\after-footer.ejs： 123&lt;!-- &lt;script src=&quot;//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js&quot;&gt;&lt;/script&gt; --&gt;&lt;script src=&quot;//cdn.bootcss.com/jquery/2.0.3/jquery.min.js&quot;&gt;&lt;/script&gt; 换成国内cdn就解决了。]]></content>
      <categories>
        <category>混合</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo-abbrlink 将中文标题转字母数字]]></title>
    <url>%2Fmixture%2F7af33d81.html</url>
    <content type="text"><![CDATA[hexo-abbrlink 安装 hexo-abbrlink1npm install hexo-abbrlink --save 如果提示安装eslin、babel-eslint： 1npm install eslint babel-eslint -D 修改 _config.yml12345permalink: :category/:abbrlink.htmlpermalink_defaults: enabbrlink: alg: crc32 #算法： crc16(default) and crc32 rep: hex #进制： dec(default) and hex 4种组合：crc16 &amp; hexhttps://post.zz173.com/posts/66c8.html crc16 &amp; dechttps://post.zz173.com/posts/65535.html crc32 &amp; hexhttps://post.zz173.com/posts/8ddf18fb.html crc32 &amp; dechttps://post.zz173.com/posts/1690090958.html 参考：https://leafjame.github.io/posts/4084686398.html]]></content>
      <categories>
        <category>混合</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>中文标题转字母数字</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分类名与路径名称分别设置]]></title>
    <url>%2Fmixture%2Fa787eed.html</url>
    <content type="text"><![CDATA[1、修改永久连接格式我把文章的 永久链接 格式修改了成:category/:title.html _config.yml： 123456# URL## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: http://yoursite.comroot: /permalink: :category/:title.htmlpermalink_defaults: en 2、设置分类添加设置了文章分类前端。 此时路径为：http://localhost:4000/前端/文章标题.html 我要url分类路径显示英文。 3、修改category_map_config.yml： 12345# Category &amp; Tagdefault_category: uncategorizedcategory_map: 前端: front-endtag_map: 此时路径为：http://localhost:4000/front-end/文章标题.html 标签同理。]]></content>
      <categories>
        <category>混合</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>个人博客</tag>
      </tags>
  </entry>
</search>
