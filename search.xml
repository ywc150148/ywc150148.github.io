<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[node.js学习笔记]]></title>
    <url>%2Fback-end%2F3c2bd137.html</url>
    <content type="text"><![CDATA[判断是否主模块在模块中写入： 12var a = module === require.main;console.log(a) // true 主模块，false 非主模块 例如：node app.js那么，app.js就是主模块 引用同一个模块不会引起模块内的代码多次运行引入模块，加载模块时会执行模块里面的全部代码，模块加载后将缓存到内存缓存区中，主模块多次引用同一个模块不会引起模块内的代码多次运行。 123var test1 = require('./testModule.js');var test2 = require('./testModule.js');var test3 = require('./testModule.js'); 获取模块文件名和当前目录12console.log("获取模块文件名:",__filename)console.log("获取当前目录:",__dirname) 取消事件的所有事件处理函数1234567891011121314151617181920212223242526272829var http = require('http');var server = http.createServer();server.on('request', function (req, res) &#123; if (req.url !== '/favicon.ico') &#123; console.log("收到客户端请求"); &#125;&#125;);server.on('request', function (req, res) &#123; // 不处理收藏加图标的请求 if (req.url !== '/favicon.ico') &#123; console.log(req.url); &#125; res.end();&#125;);// 取消'request'事件的所有事件处理函数server.removeAllListeners('request');server.on('request', function (req, res) &#123; if (req.url !== '/favicon.ico') &#123; console.log('你可以在控制台看到这句'); &#125; res.end();&#125;);server.listen(1234, "127.0.0.1"); removeAllListeners方法中使用事件名称参数时，将取消该事件的所有事件处理函数removeAllListeners方法中不使用事件名称参数时，将取消所有已被指定的事件 查看npm包全局安装路径1npm root -g 修改全局安装路径修改到 d:\node\node_module 1npmconfig set prefix &quot;d:\node&quot; 文件读写参数‘r’：读取文件．如果文件不存在则抛出异常。‘r+’：读取并写入文件，如果文件不存在则抛出异常。‘rs’：以同步方式读取文件并通知操作系统忽略本地文件系统缓存．如果文件不存在则抛出异常。由于该属性值的使用将使操作系统忽略本地文件系统缓存机制，因此在操作网络文件系统时建议使用该属性值，但由于其对性能产生一定的负面影响．所以在其他场合下不建议使用。‘w’：写人文件。如果文件不存在则创建该文件，如果该文件已存在则清空文件内容。‘wx’：作用与W类似，但是如果文件路径存在，则文件写入失败。‘w+’：读取并写人文件。如果文件不存在则创建该文件，如果该文件巳存在则清空文件内容。‘wx+’： 作用与’w+’类似，则文件读写失败。‘a’：追加写人文件。如果文件不存在则创建该文件。‘ax’：作用与’a’类似，但是如果文件路径存在，则文件追加失败。‘a+’：读取并追加写人文件，如果文件存在则创建该文件 。‘ax+’：类似 ‘a+’， 但是如果文件路径存在，则文件读取追加失败。 Buffer(缓冲区) 看书看不懂Buffer怎么使用，去官网或者菜鸟教程看一遍。node.js中文文档-buffer：http://nodejs.cn/api/buffer.html菜鸟教程-Node.js Buffer(缓冲区)：https://www.runoob.com/nodejs/nodejs-buffer.html Buffer类用来创建一个专门存放二进制数据的缓存区。 在 Node.js 中，Buffer 类是随 Node 内核一起发布的核心库。Buffer 库为 Node.js 带来了一种存储原始数据的方法，可以让 Node.js 处理二进制数据，每当需要在 Node.js 中处理I/O操作中移动的数据时，就有可能使用 Buffer 库。原始数据存储在 Buffer 类的实例中。一个 Buffer 类似于一个整数数组，但它对应于 V8 堆内存之外的一块原始内存。 在v6.0之前创建Buffer对象直接使用new Buffer()构造函数来创建对象实例，但是Buffer对内存的权限操作相比很大，可以直接捕获一些敏感信息，所以在v6.0以后，官方文档里面建议使用 Buffer.from() 接口去创建Buffer对象。 Buffer 与字符编码Buffer 实例一般用于表示编码字符的序列，比如 UTF-8 、 UCS2 、 Base64 、或十六进制编码的数据。 通过使用显式的字符编码，就可以在 Buffer 实例与普通的 JavaScript 字符串之间进行相互转换。 1234567const buf = Buffer.from('runoob', 'ascii');// 输出 72756e6f6f62console.log(buf.toString('hex'));// 输出 cnVub29iconsole.log(buf.toString('base64')); Node.js 目前支持的字符编码包括： ascii - 仅支持 7 位 ASCII 数据。如果设置去掉高位的话，这种编码是非常快的。 utf8 - 多字节编码的 Unicode 字符。许多网页和其他文档格式都使用 UTF-8 。 utf16le - 2 或 4 个字节，小字节序编码的 Unicode 字符。支持代理对（U+10000 至 U+10FFFF）。 ucs2 - utf16le 的别名。 base64 - Base64 编码。 latin1 - 一种把 Buffer 编码成一字节编码的字符串的方式。 binary - latin1 的别名。 hex - 将每个字节编码为两个十六进制字符。 创建 Buffer 类Buffer 提供了以下 API 来创建 Buffer 类： Buffer.alloc(size[, fill[, encoding]])： 返回一个指定大小的 Buffer 实例，如果没有设置 fill，则默认填满 0 Buffer.allocUnsafe(size)： 返回一个指定大小的 Buffer 实例，但是它不会被初始化，所以它可能包含敏感的数据 Buffer.allocUnsafeSlow(size) Buffer.from(array)： 返回一个被 array 的值初始化的新的 Buffer 实例（传入的 array 的元素只能是数字，不然就会自动被 0 覆盖） Buffer.from(arrayBuffer[, byteOffset[, length]])： 返回一个新建的与给定的 ArrayBuffer 共享同一内存的 Buffer。 Buffer.from(buffer)： 复制传入的 Buffer 实例的数据，并返回一个新的 Buffer 实例 Buffer.from(string[, encoding])： 返回一个被 string 的值初始化的新的 Buffer 实例 1234567891011121314151617181920// 创建一个长度为 10、且用 0 填充的 Buffer。const buf1 = Buffer.alloc(10);// 创建一个长度为 10、且用 0x1 填充的 Buffer。 const buf2 = Buffer.alloc(10, 1);// 创建一个长度为 10、且未初始化的 Buffer。// 这个方法比调用 Buffer.alloc() 更快，// 但返回的 Buffer 实例可能包含旧数据，// 因此需要使用 fill() 或 write() 重写。const buf3 = Buffer.allocUnsafe(10);// 创建一个包含 [0x1, 0x2, 0x3] 的 Buffer。const buf4 = Buffer.from([1, 2, 3]);// 创建一个包含 UTF-8 字节 [0x74, 0xc3, 0xa9, 0x73, 0x74] 的 Buffer。const buf5 = Buffer.from('tést');// 创建一个包含 Latin-1 字节 [0x74, 0xe9, 0x73, 0x74] 的 Buffer。const buf6 = Buffer.from('tést', 'latin1'); 写入缓冲区语法写入 Node 缓冲区的语法如下所示： 1buf.write(string[, offset[, length]][, encoding]) 参数参数描述如下： string - 写入缓冲区的字符串。 offset - 缓冲区开始写入的索引值，默认为 0 。 length - 写入的字节数，默认为 buffer.length encoding - 使用的编码。默认为 ‘utf8’ 。 根据 encoding 的字符编码写入 string 到 buf 中的 offset 位置。 length 参数是写入的字节数。 如果 buf 没有足够的空间保存整个字符串，则只会写入 string 的一部分。 只部分解码的字符不会被写入。 返回值返回实际写入的大小。如果 buffer 空间不足， 则只会写入部分字符串。 实例 123buf = Buffer.alloc(256);len = buf.write("www.runoob.com");console.log("写入字节数 : "+ len); // 写入字节数 : 14 从缓冲区读取数据语法读取 Node 缓冲区数据的语法如下所示： 1buf.toString([encoding[, start[, end]]]) 参数参数描述如下： encoding - 使用的编码。默认为 ‘utf8’ 。 start - 指定开始读取的索引位置，默认为 0。 end - 结束位置，默认为缓冲区的末尾。 返回值解码缓冲区数据并使用指定的编码返回字符串。 实例 123456789buf = Buffer.alloc(26);for (var i = 0 ; i &lt; 26 ; i++) &#123; buf[i] = i + 97;&#125;console.log( buf.toString('ascii')); // 输出: abcdefghijklmnopqrstuvwxyzconsole.log( buf.toString('ascii',0,5)); // 输出: abcdeconsole.log( buf.toString('utf8',0,5)); // 输出: abcdeconsole.log( buf.toString(undefined,0,5)); // 使用 'utf8' 编码, 并输出: abcde 将缓冲区内数据用fs.write写入使用fs.open打开的文件 fs.write(fd, buffer[, offset[, length[, position]]], callback)fs.write文档：http://nodejs.cn/api/fs.html#fs_fs_write_fd_string_position_encoding_callback 将 buffer 写入到 fd 指定的文件。 参数 fd &lt;integer&gt; 使用fs.open打开成功后返回的文件描述符 buffer &lt;Buffer&gt; | | &lt;DataView&gt; Buffer对象 offset &lt;integer&gt; 从缓存区中读取时的初始位置，以字节为单位 length &lt;integer&gt; 从缓存区中读取数据的字节数 position &lt;integer&gt; 写入文件初始位置 callback &lt;Function&gt; 回调函数 err &lt;Error&gt; 错误信息 written &lt;integer&gt; 写入的字节数 buffer &lt;string&gt; 被读取的缓存区对象 例子： 12345678910111213141516var fs = require('fs');var buf = Buffer.from('我爱编程');console.log(buf)console.log("准备打开文件")fs.open('./mesage.txt', 'w', function (err, fd) &#123; if (err) console.log("打开文件失败"); console.log("文件描述符：", fd) fs.write(fd, buf, 3, 9, 0, function (err, written, buffer) &#123; if (err) console.log("写文件操作失败"); console.log("文件操作成功"); console.log('写入的字节数：', written) console.log('buffer：', buffer) console.log('被读取的缓存区对象:',buffer.toString()) &#125;)&#125;) 打印结果： 1234567&lt;Buffer e6 88 91 e7 88 b1 e7 bc 96 e7 a8 8b&gt;准备打开文件文件描述符： 3文件操作成功写入的字节数： 9buffer： &lt;Buffer e6 88 91 e7 88 b1 e7 bc 96 e7 a8 8b&gt;被读取的缓存区对象: 我爱编程 mesage.txt： 1爱编程 fs.close 关闭文件]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>node.js</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node.js：console对象]]></title>
    <url>%2Fback-end%2Fb83ce424.html</url>
    <content type="text"><![CDATA[标准输出流conosole.log方法用于进行标准输出流的输出，即在控制台中显示一行字符串。 12// app.jsconsole.log("hello node.js") 运行 1node app.js 标准输出流将输出到控制台 hello node.js 重定向标准输出流将app.js输出的字符串输出到info.log文件中，（1代表重定向标准输出流） 1node app.js 1&gt;info.log 如果没有info.log，它会自动创建并写入。 打开info.log可以看到： 1hello node.js 标准错误输出流重定向输出将app.js错误信息输出的字符串输出到error.log文件中，（2代表重定向标准错误输出流） 1234// app.jsconsole.error("This is a test")// 或者输出一个未定义的变量// conosole.log(name) 如果没有error.log，它会自动创建并写入。 打开error.log可以看到： 123456node : This is a test所在位置 行:1 字符: 1+ node app.js 2&gt;error.log+ ~~~~~~~~~~~~~~~~~~~~~~~ + CategoryInfo : NotSpecified: (This is a test:String) [], RemoteException + FullyQualifiedErrorId : NativeCommandError 统计一段代码执行时间console.time(label)console.timeEnd(label) 这两个方法使用一个参数，并且这个两个方法使用的参数字符串必须相同。 1234567// app.jsconsole.time("test")var q;for(var i=0;i++;i&lt;20)&#123; q+=1;&#125;console.timeEnd("test") 运行： 1node app.js 结果： test: 0.086ms]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文档、书籍分享]]></title>
    <url>%2Fshare%2F74bd31aa.html</url>
    <content type="text"><![CDATA[后端node.js 书籍 《node.js权威指南》 作者: 陆凌牛出版社: 机械工业出版社出版年: 2014-4-1 百度云盘：https://pan.baidu.com/s/1vvYZfVnqn98BdVK39itMnw提取码：d40u node.js 文章、文档 Node.js 中文网文档文档地址：http://nodejs.cn/api/ node.js fs.open 和 fs.write 读取文件和改写文件文章地址： https://www.cnblogs.com/wushanbao/p/7003308.html 七天学会NodeJS文档地址：https://nqdeng.github.io/7-days-nodejs/#1]]></content>
      <categories>
        <category>分享</category>
      </categories>
      <tags>
        <tag>学习书籍</tag>
        <tag>pdf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[fis3前端工程构建工具]]></title>
    <url>%2Ffront-end%2F664fd9e5.html</url>
    <content type="text"><![CDATA[昨天尝试webapck使用ejs模板配置公用组件，网上关于webpack使用ejs配置公用组件的教程太少了，有几个教程我尝试了，都以失败告终。 ejs官网：https://ejs.bootcss.com/ 开发原生多页面项目，不同于使用vue，repeat这些框架，很多重复的部件，公用头部、底部，导航等等，管理起来太费时间了，好像glup也可以做到公用组件，但是不想要glup。 fis3是一个不错的选择，因为简单容易使用，我只针对使用它的一个功能也足够了。 在html中嵌入资源：http://fis.baidu.com/fis3/docs/user-dev/inline.html html中嵌入页面文件 源码： 1234// index.html&lt;div class="layout"&gt; &lt;link rel="import" href="head.html?__inline"&gt;&lt;/div&gt; 12// head.html (公共组件)&lt;h1&gt;这里是头部&lt;/h1&gt; 编译后： 1234// index.html&lt;div class="layout"&gt; &lt;h1&gt;这里是头部&lt;/h1&gt;&lt;/div&gt; 配置好一个demo，有点贪心加了其他功能进去，github:https://github.com/ywc150148/fis-demo 但是好像挺少人使用fis3，配置sass失败，找不到解决方法。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>fis3</tag>
        <tag>前端工程构建工具</tag>
        <tag>前端公用组件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo及next主题使用遇到的问题]]></title>
    <url>%2Fmixture%2Fb13ba7b7.html</url>
    <content type="text"><![CDATA[我在使用hexo和next主题，期间遇到问题的解决方法一一罗列： 安装使用 next 主题http://theme-next.iissnan.com/ Hexo使用不蒜子统计功能失效问题解决https://www.jianshu.com/p/089762f90e1c hexo博客添加评论神器—valinehttps://blog.csdn.net/qq_40265501/article/details/80019508 Hexo Next 主题中添加本地搜索功能https://blog.csdn.net/lijing742180/article/details/87970909 Hexo之next主题设置首页不显示全文(只显示预览)https://www.jianshu.com/p/393d067dba8d 资源文件夹https://hexo.io/zh-cn/docs/asset-folders.html hexo+github上传图片到博客 (这个会创建很多文件夹，我不使用)https://www.jianshu.com/p/8d28027fec76 建议把图片压缩再放到source文件夹图片在线压缩：https://www.tuhaokuai.com/ hexo禁用特定文章的评论https://blog.csdn.net/jiluben/article/details/40868981]]></content>
      <categories>
        <category>混合</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>hexo next 主题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Funcategorized%2F4a17b156.html</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment 启动 Hexo 本地站点，并开启调试模式1$ hexo s --debug 清除缓存、生产并部署到主分支12$ hexo clean$ hexo d -g]]></content>
  </entry>
  <entry>
    <title><![CDATA[hexo jquery 加载失败问题]]></title>
    <url>%2Fmixture%2F9e5800d1.html</url>
    <content type="text"><![CDATA[昨天部署上线hexo，想在手机上体验一番，但是奈何进度条一直显示加载状态，而且导航栏按钮点击无效。 打开pc谷歌浏览器控制台，提示错误： 123456GET https://ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js net::ERR_CONNECTION_TIMED_OUTjquery.fancybox.pack.js:46 Uncaught ReferenceError: jQuery is not defined at jquery.fancybox.pack.js:46(anonymous) @ jquery.fancybox.pack.js:46script.js:137 Uncaught ReferenceError: jQuery is not defined at script.js:137 打开themes\landscape\layout_partial\after-footer.ejs： 123&lt;!-- &lt;script src=&quot;//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js&quot;&gt;&lt;/script&gt; --&gt;&lt;script src=&quot;//cdn.bootcss.com/jquery/2.0.3/jquery.min.js&quot;&gt;&lt;/script&gt; 换成国内cdn就解决了。]]></content>
      <categories>
        <category>混合</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo-abbrlink 将中文标题转字母数字]]></title>
    <url>%2Fmixture%2F7af33d81.html</url>
    <content type="text"><![CDATA[hexo-abbrlink 安装 hexo-abbrlink1npm install hexo-abbrlink --save 如果提示安装eslin、babel-eslint： 1npm install eslint babel-eslint -D 修改 _config.yml12345permalink: :category/:abbrlink.htmlpermalink_defaults: enabbrlink: alg: crc32 #算法： crc16(default) and crc32 rep: hex #进制： dec(default) and hex 4种组合：crc16 &amp; hexhttps://post.zz173.com/posts/66c8.html crc16 &amp; dechttps://post.zz173.com/posts/65535.html crc32 &amp; hexhttps://post.zz173.com/posts/8ddf18fb.html crc32 &amp; dechttps://post.zz173.com/posts/1690090958.html 参考：https://leafjame.github.io/posts/4084686398.html]]></content>
      <categories>
        <category>混合</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>中文标题转字母数字</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分类名与路径名称分别设置]]></title>
    <url>%2Fmixture%2Fa787eed.html</url>
    <content type="text"><![CDATA[1、修改永久连接格式我把文章的 永久链接 格式修改了成:category/:title.html _config.yml： 123456# URL## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: http://yoursite.comroot: /permalink: :category/:title.htmlpermalink_defaults: en 2、设置分类添加设置了文章分类前端。 此时路径为：http://localhost:4000/前端/文章标题.html 我要url分类路径显示英文。 3、修改category_map_config.yml： 12345# Category &amp; Tagdefault_category: uncategorizedcategory_map: 前端: front-endtag_map: 此时路径为：http://localhost:4000/front-end/文章标题.html 标签同理。]]></content>
      <categories>
        <category>混合</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>个人博客</tag>
      </tags>
  </entry>
</search>
